{
  "algorithm": "import pandas as pd\nimport lightgbm as lgb\nimport pywt\nimport xgboost as xgb\nimport matplotlib.pyplot as plt\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n\n# LGBM特征提取_随机森林分类\ndef LGBM_feature_extract(file_name):\n    # 读取数据\n    data = pd.read_excel(file_name)\n\n    # 准备数据\n    X = data.iloc[:, :160]  # 假设前160列是特征\n    y = data.iloc[:, -1]  # 最后一列是目标值\n\n    # 定义LightGBM模型参数\n    params = {\n        'objective': 'multiclass',  # 多分类问题\n        'num_class': 3,  # 类别数\n        'metric': 'multi_logloss',  # 评估指标\n    }\n\n    # 创建LightGBM数据集\n    lgb_dataset = lgb.Dataset(X, label=y)\n\n    # 训练LightGBM模型并获取特征重要性\n    model = lgb.train(params, lgb_dataset)\n    feature_importance = model.feature_importance()\n\n    # 排序特征重要性\n    sorted_idx = feature_importance.argsort()\n    sorted_features = X.columns[sorted_idx]\n    sorted_scores = feature_importance[sorted_idx]\n\n    # print(sorted_idx[::-1])\n    # 绘制柱形图\n    plt.figure(figsize=(20, 50))\n    plt.barh(range(len(sorted_scores)), sorted_scores, tick_label=sorted_features)\n    plt.xlabel('Feature Importance')\n    plt.ylabel('Features')\n    plt.title('LightGBM Feature Importance')\n    plt.savefig('result/LGBM_feature_extract.png')\n\n\n# XGBoost特征提取\n\n# 使用XGBoost进行特征提取\n\n\n# 读取数据\ndef xgboost_feature_extract(file_name):\n    data = pd.read_excel(file_name)\n    # 准备数据\n    X = data.iloc[:, :160]  # 假设前160列是特征\n    y = data.iloc[:, -1]  # 最后一列是目标值\n\n    # 定义XGBoost模型参数\n    params = {\n        'objective': 'multi:softprob',  # 多分类问题\n        'num_class': 3,  # 类别数\n        'eval_metric': 'mlogloss',  # 评估指标\n        # 更多参数设置...\n    }\n\n    # 创建XGBoost数据集\n    dtrain = xgb.DMatrix(X, label=y)\n\n    # 训练XGBoost模型并获取特征重要性\n    model = xgb.train(params, dtrain)\n    feature_importance = model.get_score(importance_type='gain')\n\n    # 将特征重要性转换为DataFrame\n    sorted_features = sorted(feature_importance, key=feature_importance.get)\n    sorted_scores = [feature_importance[feat] for feat in sorted_features]\n    df_feature_importance = pd.DataFrame({'Feature': sorted_features, 'Importance': sorted_scores})\n\n    # print(sorted_features[::-1])\n\n    # 绘制柱形图\n    plt.figure(figsize=(20, 30))\n    plt.barh(range(len(sorted_scores)), sorted_scores, tick_label=sorted_features)\n    plt.xlabel('Feature Importance')\n    plt.ylabel('Features')\n    plt.title('XGBoost Feature Importance')\n    plt.savefig('result/xgboost_feature_extract.png')\n\n\n# 随机森林分类\ndef forest_sorted(file_name):\n    # 读取Excel文件\n    data = pd.read_excel(file_name)\n\n    # 提取特征和标签\n    features = data.iloc[:, :40]  # 前30列作为特征\n    labels = data.iloc[:, -1]  # 最后一列作为标签\n\n    test_accuracy = []\n    for i in range(30):\n        # 划分训练集和测试集\n        X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)\n\n        # 创建随机森林分类器\n        rf_classifier = RandomForestClassifier()\n\n        # 拟合模型\n        rf_classifier.fit(X_train, y_train)\n\n        # 预测\n        predictions = rf_classifier.predict(X_test)\n\n        # 计算准确率\n        accuracy = accuracy_score(y_test, predictions)\n        print(f'准确率：{accuracy}')\n        test_accuracy.append(accuracy)\n    import matplotlib.pyplot as plt\n\n    # 横轴序号\n    x_values = list(range(1, len(test_accuracy) + 1))\n\n    # 绘制折线图\n    plt.plot(x_values, test_accuracy, marker='o')\n\n    # 添加标题和标签\n    plt.title('折线图')\n    plt.xlabel('序号')\n    plt.ylabel('数值')\n\n    # 显示图形\n    plt.savefig('result/forest_sorted.png')\n\n\ndef dwt(file_name):\n    # 读取Excel数据\n    df = pd.read_excel(file_name)\n\n    # db8，软阈值0.5\n    methmod = 'db8'\n    threshold = 0.5\n\n    # 创建一个DataFrame用于保存降噪后的数据\n    denoised_df = df.copy()\n\n    for i in range(0, 16):\n        # 选择一个传感器的数据进行降噪处理\n        sensor_data = df[f'AI{i}(V)'].values\n\n        # 对数据进行离散小波变换\n        coeffs = pywt.wavedec(sensor_data, methmod, level=6)\n\n        # 将高频噪声系数j设置为0\n        for j in range(1, len(coeffs)):\n            coeffs[j] = pywt.threshold(coeffs[j], value=threshold, mode='soft')\n\n        # 基于修正的系数进行逆变换\n        denoised_data = pywt.waverec(coeffs, methmod)\n\n        # 替换原始数据列为降噪后的数据\n        denoised_df[f'AI{i}(V)'] = denoised_data\n\n        plt.figure(figsize=(12, 6))\n        plt.subplot(1, 2, 1)\n        plt.plot(sensor_data)\n        plt.title('Original data')\n        plt.subplot(1, 2, 2)\n        plt.plot(denoised_data)\n        plt.title('Denoised data')\n        plt.savefig('result/dwt.png')\n"
}
